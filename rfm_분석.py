# -*- coding: utf-8 -*-
"""RFM 분석.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZzcN_9p0ySH8VJ_jqPImw3b5zng_6IAa

# RFM 분석
- 데이터 출처 : 데이콘 - 이커머스 고객 세분화 분석
[https://dacon.io/competitions/official/236222/overview/description]
"""

import pandas as pd
import numpy as np
import plotly.express as px

## 경고 메시지 무시
import warnings
warnings.filterwarnings('ignore')

"""# 데이터 불러오기"""

# Commented out IPython magic to ensure Python compatibility.
## 파일 실행 경로 설정
# %cd /content/drive/MyDrive/플젝/[데분 과제]/이커머스 고객 세분화 분석 - rfm/rfm
# %ls

### 파일 불러오기
customer = pd.read_csv('Customer_info.csv')
marketing = pd.read_csv('Marketing_info.csv')
discount = pd.read_csv('Discount_info.csv')
online = pd.read_csv('Onlinesales_info.csv')
tax = pd.read_csv('Tax_info.csv')

"""# 데이터 확인 및 전처리

## customer
: 고객과 관련된 정보

*   고객ID : 고객 고유 ID
*   성별 : 고객 성별
* 고객지역 : 고객지역
* 가입기간 : 가입기간 (단위 : 월)
"""

customer.head()

customer.info()
### 결측치 없음

##고객 아이디
customer['고객ID'].nunique()
### 다 다름

## 성별 분포
customer['성별'].value_counts()
### 2:1

##고객 가입 지역 분포
print(customer['고객지역'].unique())
customer['고객지역'].value_counts()
## 지역은 5개

## 가입 기간 분포 그래프
fig = px.histogram(customer, x='가입기간')
fig.show()

"""### 상관 분석"""

### 성별과 가입 기간 상관 분석
fig = px.box(customer, x='성별', y='가입기간')
fig.show()
### 비슷함

### 지역과 가입 기간 상관분석
fig = px.box(customer, x='고객지역', y='가입기간')
fig.show()
### 얼추 비슷

### 성별과 지역 상관 분석
fig = px.box(customer, x='성별', y='고객지역')
fig.show()
### 비슷함

"""## marketing
:
마케팅비용과 관련된 정보
* 날짜 : 마케팅이 이루어진 날짜
* 오프라인비용 : 오프라인 마케팅으로 지출한 비용 (단위 : 달러)
* 온라인비용 : 온라인 마케팅으로 지출한 비용 (단위 : 달러)
"""

marketing.head()

marketing.describe()
### 결측치 없음

marketing.info()
## 결측치 없음

## 날짜 변환
marketing['날짜'] = pd.to_datetime(marketing['날짜'])
### 2019-01-01 ~ 2019-12-31

## 날짜별 온/오프라인 비용 비교
fig = px.line(marketing, x='날짜', y=['온라인비용', '오프라인비용'])
fig.show()
### 온라인 비용 많이 쓰면 오프라인 비용도 많이 씀



"""## Tax
: 세금과 관련된 정보
* 제품 카테고리 : 제품이 포함된 카테고리
* GST : Goods and Services Tax(%)
"""

tax.info()

tax.head()

tax['제품카테고리'].nunique()
## 중복 없음

## GST별 카테고리 그룹화
tax['GST']



"""## Discount
: 할인과 관련된 정보
* 월 : 월(Month) 정보
* 제품카테고리 : 제품이 포함된 카테고리
* 쿠폰코드 : 쿠폰코드
* 할인율 : 해당 쿠폰에 대한 할인율(%)
"""

print(discount.shape)
discount.head()

discount.info()
## 결측치 없음

## 월별 평균 할인율
fig = px.line(discount, x='월', y='할인율')
fig.show()

### 월별로 품목 상관없이 모든 제품의 할인률이 같나?
discount[discount['월'] == 'Dec']
### 같음

## 월 형식 변경
month_mapping = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                 'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}

discount['월'] = discount['월'].map(month_mapping)
discount.head()

"""## oneline
- 온라인거래와 관련된 정보
- 고객ID : 고객 고유 ID
- 거래ID : 거래 고유 ID
- 거래날짜 : 거래가 이루어진 날짜
- 제품ID : 제품 고유 ID
- 제품카테고리 : 제품이 포함된 카테고리
- 수량 : 주문한 품목 수
- 평균금액 : 수량 1개당 가격 (단위 : 달러)
  - 동일 상품이어도 세부 옵션에 따라 가격이 다를 수 있음
- 배송료 : 배송비용 (단위 : 달러)
- 쿠폰상태 : 할인쿠폰 적용 상태
"""

online.head()

online.info()
### 결측치 없음

## 거래날짜 데이터 타입변환 -> datetime64
online['거래날짜'] = pd.to_datetime(online['거래날짜'])

"""#데이터 병합
- 모든 데이터 결측치 없음
"""

## online + customer
### KEY = 고객ID
df = pd.merge(online, customer, on='고객ID', how='left')

df.head()

print(df.shape)
print(online.shape)
### 제대로 병합되었는지, 크기가 늘어나지 않았는지 확인

## discount(쿠폰 정보) + df
### KEY = 월, 제품카테고리
#### df는 월 없으므로 만둘어야함
df['월'] = df['거래날짜'].dt.month
df = pd.merge(df, discount, on=['월', '제품카테고리'], how='left')

print(df.shape)
print(online.shape)
df.head()

## tax(세율) + df
### KEY = 제품카테고리
df = pd.merge(df, tax, on='제품카테고리', how='left')

print(df.shape)
print(online.shape)
df.head()





"""## 결측치 확인"""

df.info()
### 쿠폰코드랑 할인율 결측치 있음

#### 쿠폰 코드랑 할인율 0인 항목 있음 -> 세일 안한 항목으로 간주하고 0으로 채우겠음
df['쿠폰코드'].fillna('None', inplace=True)
df['할인율'].fillna(0, inplace=True)

df[df['할인율'] == 0].head()



"""# 피쳐 생성

### 쿠폰 사용 여부
"""

### 쿠폰 사용 여부 -> 사용에 따른 금액 / 사람들이 쿠폰에 관심 있는가 확인
df['쿠폰상태'].unique()
df['쿠폰사용여부'] = df['쿠폰상태'].apply(lambda x: 1 if x == 'Used' else 0)
### 쿠폰 사용이면 1 아니면 0

df.head()

"""### 금액
- 주문 당 금액
- 주문 금액에 세금 포함
- 총 지불한 금액(쿠폰 사용에 따른 할인 등 반영)
"""

# 전체금액 = (수량 * 평균금액)
# 전체금액_VAT포함 = (수량 * 평균금액) * (1 + tax)
# 지불금액 = (수량 * 평균금액) * (1 - 할인율*쿠폰사용여부 / 100) * (1 + tax)

df['주문금액'] = (df['수량'] * df['평균금액'])
df['주문금액_VAT포함'] = (df['수량'] * df['평균금액']) * (1 + df['GST'])
df['지불금액'] = (df['수량'] * df['평균금액']) * (1 + df['GST']) * (1 - (df['할인율'] * df['쿠폰사용여부'] / 100))

df.head()



"""# RFM
- 사용자별로 얼마나 최근에, 얼마나 자주, 얼마나 많은 금액을 지출했는지 사용자 분포 및 그룹화

1. Recency : 얼마나 최근에 구매했는가
2. Frequency : 얼마나 자주 구매했는가
3. Monetary : 얼마나 많은 금액을 지출했는가
"""



"""## RFM 데이터 생성

### 고객별 RFM 계산
- Recency
- Frquenecy
- Monetary
"""

# 데이터의 마지막날 +1일을 기준으로 잡음
last = df['거래날짜'].max() + pd.DateOffset(days=1)  # 2019-12-31 + 1일 = 2020-01-01
### DataOffset()

rfm_df = df.groupby(['고객ID']).agg({
    '거래날짜': lambda x: (last - x.max()).days,
    '거래ID': lambda x: x.nunique(),
    '지불금액': 'sum'
    })

rfm_df.rename(columns={'거래날짜': 'Recency',
                         '거래ID': 'Frequency',
                         '지불금액': 'Monetary'}, inplace=True)

rfm_df.head()

"""### 시각화"""

# Recency, Frequency, Monetary 고객 분포 시각화
px.histogram(rfm_df, x=['Recency'])

px.histogram(rfm_df, x=['Frequency'])

px.histogram(rfm_df, x=['Monetary'])

## 산점도
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
sns.scatterplot(data=rfm_df, x='Recency', y='Frequency')
plt.title('Recency vs Frequency')
plt.xlabel('Recency')
plt.ylabel('Frequency')

plt.subplot(1, 3, 2)
sns.scatterplot(data=rfm_df, x='Recency', y='Monetary')
plt.title('Recency vs Monetary')
plt.xlabel('Recency')
plt.ylabel('Monetary')

plt.subplot(1, 3, 3)
sns.scatterplot(data=rfm_df, x='Frequency', y='Monetary')
plt.title('Frequency vs Monetary')
plt.xlabel('Frequency')
plt.ylabel('Monetary')

plt.tight_layout()
plt.show()





"""## 등급화

### R
"""

### Recency를 6단계로 구분 : 비즈니스 로직에서 가장 많이 하는 1,2,3,6개월, 1년으로 등급화
def R(recency):
    if recency <= 30:    # 최근 1개월
        return 5
    elif recency <= 60:   # 최근 2개월
        return 4
    elif recency <= 90:   # 최근 3개월
        return 3
    elif recency <= 180:  # 최근 6개월
        return 2
    elif recency <= 365:  # 최근 1년
        return 1
    else:
        return 0

rfm_df['R'] = rfm_df['Recency'].apply(R)

rfm_df.head()

### r등급화 갯수
rfm_df.groupby('R').count()

## r등급화 평균
rfm_df.groupby('R').mean()





"""### F"""

## Frequency 분포 시각화
px.box(rfm_df, y='Frequency')

rfm_df[rfm_df['Frequency'] >= 50].shape

rfm_df['Frequency'].min(), rfm_df['Frequency'].max(), rfm_df['Frequency'].mean(), rfm_df['Frequency'].median()

rfm_df['F'] = rfm_df['Frequency'].apply(lambda x: 50 if x >= 50 else x)

def create_bins(series, method='quantile', bins=10, labels=None):
    """
    연속형 컬럼 binning 함수

    Parameters:
        series : pd.Series (연속형 데이터)
        method : 'quantile' (분위수) or 'uniform' (균등)
        bins : 구간 수
        labels : 구간 이름 리스트 (default None -> 자동 생성)

    Returns:
        pd.Series : binning된 구간
    """
    if method == 'quantile':
        binned = pd.qcut(series, q=bins, labels=labels, duplicates='drop')
    elif method == 'uniform':
        binned = pd.cut(series, bins=bins, labels=labels)
    else:
        raise ValueError("method는 'quantile' 또는 'uniform'만 가능합니다.")

    return binned


create_bins(rfm_df['F'], method='quantile', bins=5).value_counts().sort_index()

create_bins(rfm_df['F'], method='uniform', bins=5).value_counts().sort_index()

rfm_df['F'] = create_bins(rfm_df['F'], method='quantile', bins=5, labels=[1, 2, 3, 4, 5])
rfm_df.head()



"""### M"""

plt.figure(figsize=(8, 6))
sns.boxplot(y=rfm_df['Monetary'])
plt.title('Box-Plot (Monetary)')
plt.grid(True)
plt.show()

create_bins(rfm_df['Monetary'], method='quantile', bins=5).value_counts().sort_index()

rfm_df['M'] = create_bins(rfm_df['Monetary'], method='quantile', bins=5, labels=[1, 2, 3, 4, 5])
rfm_df.head()

rfm_df['F'] = rfm_df['F'].astype('int')
rfm_df['M'] = rfm_df['M'].astype('int')

"""## RFM 스코어 생성"""

rfm_df['RFM_Score'] = rfm_df['R'] + rfm_df['F'] + rfm_df['M']
rfm_df.head()

rfm_df.groupby(['RFM_Score'])[['Recency', 'Frequency', 'Monetary']].mean()



"""## RFM 기반 고객 분류"""

def classify_customer(row):
    r, f, m = row['R'], row['F'], row['M']

     # VIP
    if r >= 5 and f >= 5 and m >= 5:
        return 'VIP'
    # VIP이탈고객: Recency 점수가 3 이하이며, 나머지 점수가 4 이상
    elif r <= 3 and (f >= 4 and m >= 4):
        return 'VIP이탈고객'
    elif f >= 4 and r >= 4 and m >= 4:
        return '충성고객'
    elif f >= 3 and r >= 3 and m >= 3:
        return '충성예정고객'
    elif r <= 2 and f >= 3:
        return '충성이탈예정고객'
    else:
        return '일반고객'  # 이외의 경우를 위한 기본값

rfm_df['고객등급'] = rfm_df.apply(classify_customer, axis=1)



rfm_df.head()

customer_grade_counts_desc = rfm_df['고객등급'].value_counts().sort_values(ascending=False)


px.bar(x=customer_grade_counts_desc.index, y=customer_grade_counts_desc.values)

